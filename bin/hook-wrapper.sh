#!/bin/sh
# hook-wrapper.sh - POSIX-compatible wrapper for lazy binary download
# Checks if binary exists AND version matches, downloads if needed, runs hook
#
# This wrapper enables auto-download of binaries after plugin auto-update.
# Claude Code plugins don't have post-install hooks, so we use lazy loading.
#
# RELIABILITY: All operations use || true to never block Claude.

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PLUGIN_JSON="$SCRIPT_DIR/../.claude-plugin/plugin.json"
INSTALL_SCRIPT="$SCRIPT_DIR/install.sh"

# On Windows prefer the native .exe (reliable from sh). Keep .bat for users who run it from cmd.exe.
detect_windows_binary() {
    # Allow overriding for debugging/custom installs
    if [ -n "${CLAUDE_NOTIFICATIONS_BIN:-}" ] && [ -f "$CLAUDE_NOTIFICATIONS_BIN" ]; then
        BINARY="$CLAUDE_NOTIFICATIONS_BIN"
        return 0
    fi

    # Prefer the downloaded Windows executable (supports argv reliably)
    arch_raw="$(uname -m 2>/dev/null || true)"
    arch=""
    case "$arch_raw" in
        x86_64|amd64) arch="amd64" ;;
        arm64|aarch64) arch="arm64" ;;
        *) arch="" ;;
    esac

    if [ -n "$arch" ] && [ -f "$SCRIPT_DIR/claude-notifications-windows-$arch.exe" ]; then
        BINARY="$SCRIPT_DIR/claude-notifications-windows-$arch.exe"
        return 0
    fi

    # Fallback: any Windows executable present
    for exe in "$SCRIPT_DIR"/claude-notifications-windows-*.exe; do
        if [ -f "$exe" ]; then
            BINARY="$exe"
            return 0
        fi
    done

    # Fallback: legacy wrapper generated by install.sh
    BINARY="$SCRIPT_DIR/claude-notifications.bat"
    return 0
}

run_windows_bat() {
    # Best-effort: run .bat via cmd.exe (Git Bash/MSYS/Cygwin)
    if command -v cmd.exe >/dev/null 2>&1; then
        WIN_BIN="$BINARY"
        if command -v cygpath >/dev/null 2>&1; then
            WIN_BIN="$(cygpath -w "$BINARY" 2>/dev/null || printf '%s' "$BINARY")"
        fi
        # Let the runtime build a command line from argv (handles spaces reasonably well).
        # NOTE: Avoid manual quoting/escaping here; MSYS/Cygwin handle argv → Windows command line conversion.
        cmd.exe /d /s /c call "$WIN_BIN" "$@"
        return $?
    fi

    # Last resort (may fail under sh)
    "$BINARY" "$@"
}

run_binary() {
    if [ "$IS_WINDOWS" = 1 ]; then
        case "$BINARY" in
            *.bat|*.cmd) run_windows_bat "$@" ;;
            *)           "$BINARY" "$@" ;;
        esac
    else
        "$BINARY" "$@"
    fi
}

# Platform detection
# Primary: uname -s (Git Bash, MSYS2, Cygwin)
# Fallback: $OS env var (set to "Windows_NT" on ALL Windows systems, even non-MSYS shells)
IS_WINDOWS=0
case "$(uname -s)" in
    MINGW*|MSYS*|CYGWIN*) IS_WINDOWS=1 ;;
esac
if [ "$IS_WINDOWS" = 0 ]; then
    case "${OS:-}" in
        Windows*) IS_WINDOWS=1 ;;
    esac
fi

if [ "$IS_WINDOWS" = 1 ]; then
    detect_windows_binary
else
    BINARY="$SCRIPT_DIR/claude-notifications"
fi

# Guard: if BINARY is a Git text-symlink stub (not a real symlink), resolve or invalidate it.
# Git on Windows (core.symlinks=false) creates plain text files instead of symlinks.
# Content is just the target name, e.g. "claude-notifications-darwin-arm64".
if [ -f "$BINARY" ] && [ ! -L "$BINARY" ]; then
    # Text stubs are tiny (<1KB). Skip real binaries (MB-sized) to avoid false positives.
    _size=$(wc -c < "$BINARY" 2>/dev/null || echo 999999)
    if [ "$_size" -lt 1024 ]; then
        # Read first 256 bytes max (avoid reading huge files if size check is bypassed)
        _first_line=$(head -c 256 "$BINARY" 2>/dev/null | head -n 1 | tr -d '[:space:]')
        case "$_first_line" in
            claude-notifications-darwin-*|claude-notifications-linux-*|claude-notifications-windows-*)
                # Text stub detected — resolve to actual target if it exists
                if [ -x "$SCRIPT_DIR/$_first_line" ]; then
                    BINARY="$SCRIPT_DIR/$_first_line"
                else
                    # Target doesn't exist (wrong platform) — force re-install
                    BINARY="$SCRIPT_DIR/claude-notifications-MISSING"
                fi
                ;;
        esac
    fi
fi

# Check if binary is ready (exists and executable on Unix, exists on Windows)
binary_ok() {
    if [ "$IS_WINDOWS" = 1 ]; then
        [ -f "$BINARY" ]
    else
        [ -x "$BINARY" ]
    fi
}

# Get version from binary or plugin.json (returns empty on failure)
get_binary_version() {
    run_binary version 2>/dev/null | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -n 1 || true
}

get_plugin_version() {
    [ -f "$PLUGIN_JSON" ] && grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' "$PLUGIN_JSON" | head -n 1 || true
}

# Run install.sh (silent, never fails the script)
run_install() {
    [ -f "$INSTALL_SCRIPT" ] || return 0
    INSTALL_TARGET_DIR="$SCRIPT_DIR" "$INSTALL_SCRIPT" "$@" >/dev/null 2>&1 || true
}

# === Main Logic ===

NEED_INSTALL=0
NEED_FORCE=0

if ! binary_ok; then
    # Binary missing - need install
    NEED_INSTALL=1
else
    # Binary exists - check version
    BIN_VER=$(get_binary_version)
    PLG_VER=$(get_plugin_version)

    # Update only if both versions are known and differ
    if [ -n "$BIN_VER" ] && [ -n "$PLG_VER" ] && [ "$BIN_VER" != "$PLG_VER" ]; then
        NEED_INSTALL=1
        NEED_FORCE=1
    fi
fi

# Install if needed and notify user
if [ "$NEED_INSTALL" = 1 ]; then
    if [ "$NEED_FORCE" = 1 ]; then
        run_install --force
    else
        run_install
    fi

    # On Windows, re-detect binary after install to prefer .exe over .bat
    if [ "$IS_WINDOWS" = 1 ]; then
        detect_windows_binary
    fi

    if binary_ok; then
        NEW_VER=$(get_binary_version)
        if [ "$NEED_FORCE" = 1 ]; then
            printf '{"systemMessage":"[claude-notifications] Updated to v%s"}\n' "$NEW_VER"
        else
            printf '{"systemMessage":"[claude-notifications] Installed v%s"}\n' "$NEW_VER"
        fi
    fi
fi

# Run hook or exit gracefully
if binary_ok; then
    # Export plugin root so the binary can find ClaudeNotifier.app and other resources
    if [ -z "$CLAUDE_PLUGIN_ROOT" ]; then
        CLAUDE_PLUGIN_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
    fi
    export CLAUDE_PLUGIN_ROOT
    run_binary "$@" || true
fi

exit 0
